Describe Vim.Console
  Before all
    function! TestVitalVimConsoleTrue() abort
      return 1
    endfunction

    function! TestVitalVimConsoleFalse() abort
      return 0
    endfunction

    function! s:messages() abort
      redir => contents
      messages
      redir END
      let l:messages = filter(split(contents, '\r\?\n'), '!empty(v:val)')
      " Remove a title console if exists
      if get(l:messages, 0, '') =~# '^Messages maintainer:'
        return l:messages[1:]
      else
        return l:messages
      endif
    endfunction
  End

  After all
    delfunction TestVitalVimConsoleTrue
    delfunction TestVitalVimConsoleFalse
  End

  Before
    let Console = vital#vital#import('Vim.Console')
    let Console.prefix = ''
    let Console.status = Console.STATUS_BATCH
    call Console.clear()
    set verbose=0
  End

  Describe .echo({msg}[, {hl}])
    It echo a {msg}
      redir => contents
      call Console.echo("foo\nbar")
      call Console.echo("foo\nbar")
      redir END
      Assert Equals(split(contents, '\r\?\n'), ['foo', 'bar', 'foo', 'bar'])
      let messages = s:messages()
      Assert Equals(messages, [])
    End

    It echo a {msg} with {prefix}
      let Console.prefix = '[prefix] '
      redir => contents
      call Console.echo("foo\nbar")
      call Console.echo("foo\nbar")
      redir END
      Assert Equals(split(contents, '\r\?\n'), [
            \ '[prefix] foo',
            \ '[prefix] bar',
            \ '[prefix] foo',
            \ '[prefix] bar',
            \])
      let messages = s:messages()
      Assert Equals(messages, [])
    End
  End

  Describe .echon({msg}[, {hl}])
    It echon a {msg}
      redir => contents
      call Console.echon("foo\nbar")
      call Console.echon("foo\nbar")
      echo ""
      redir END
      Assert Equals(split(contents, '\r\?\n'), ['foo', 'barfoo', 'bar'])
      let messages = s:messages()
      Assert Equals(messages, [])
    End

    It echon a {msg} without {prefix}
      let Console.prefix = '[prefix] '
      redir => contents
      call Console.echon("foo\nbar")
      call Console.echon("foo\nbar")
      echo ""
      redir END
      Assert Equals(split(contents, '\r\?\n'), ['foo', 'barfoo', 'bar'])
      let messages = s:messages()
      Assert Equals(messages, [])
    End
  End

  Describe .echomsg({hl} [, {msg}...])
    It echomsg a {msg}
      redir => contents
      call Console.echomsg("foo\nbar")
      call Console.echomsg("foo\nbar")
      redir END
      Assert Equals(split(contents, '\r\?\n'), ['foo', 'bar', 'foo', 'bar'])
      let messages = s:messages()
      Assert Equals(messages, ['foo', 'bar', 'foo', 'bar'])
    End

    It echomsg a {msg} with {prefix}
      let Console.prefix = '[prefix] '
      redir => contents
      call Console.echomsg("foo\nbar")
      call Console.echomsg("foo\nbar")
      redir END
      Assert Equals(split(contents, '\r\?\n'), [
            \ '[prefix] foo',
            \ '[prefix] bar',
            \ '[prefix] foo',
            \ '[prefix] bar',
            \])
      let messages = s:messages()
      Assert Equals(messages, [
            \ '[prefix] foo',
            \ '[prefix] bar',
            \ '[prefix] foo',
            \ '[prefix] bar',
            \])
    End
  End

  Describe .input({hl}, {msg}[, {text}, {complete}])
    It returns '' while status is STATUS_BATCH
      Assert Equals(Console.input('None', 'foo'), '')
    End
  End

  Describe .inputlist({hl}, {textlist})
    It returns 0 while status is STATUS_BATCH
      Assert Equals(Console.inputlist('None', ['foo', 'bar']), 0)
    End
  End

  Describe .clear()
    It fills up messages with empty strings
      echomsg 'foo'
      echomsg 'foo'
      echomsg 'foo'
      echomsg 'foo'
      call Console.clear()
      let messages = s:messages()
      Assert Equals(len(messages), 0)
    End
  End

  Describe .debug({msg})
    It echomsg a message when status is STATUS_DEBUG
      let Console.status = Console.STATUS_DEBUG

      redir => contents
      call Console.debug('foo bar')
      redir END
      Assert Equals(split(contents, '\r\?\n'), ['foo bar'])

      let messages = s:messages()
      Assert Equals(messages, ['foo bar'])
    End

    It echomsg messages when &verbose > 0
      redir => contents
      verbose call Console.debug('foo bar')
      redir END
      Assert Equals(split(contents, '\r\?\n'), ['foo bar'])

      let messages = s:messages()
      Assert Equals(messages, ['foo bar'])
    End

    It does nothing otherwise
      redir => contents
      call Console.debug('foo bar')
      redir END
      Assert Equals(split(contents, '\r\?\n'), [])

      let messages = s:messages()
      Assert Equals(messages, [])
    End
  End

  Describe .info({msg})
    It echomsg a message
      redir => contents
      call Console.info('foo bar')
      redir END
      Assert Equals(split(contents, '\r\?\n'), ['foo bar'])

      let messages = s:messages()
      Assert Equals(messages, ['foo bar'])
    End

    It sets v:statusmsg
      redir => contents
      call Console.info('foo bar')
      redir END
      Assert Equals(v:statusmsg, 'foo bar')
    End
  End

  Describe .warn({msg})
    It echomsg a message
      redir => contents
      call Console.warn('foo bar')
      redir END
      Assert Equals(split(contents, '\r\?\n'), ['foo bar'])

      let messages = s:messages()
      Assert Equals(messages, ['foo bar'])
    End

    It sets v:warningmsg
      redir => contents
      call Console.warn('foo bar')
      redir END
      Assert Equals(v:warningmsg, 'foo bar')
    End
  End

  Describe .error({msg})
    It echomsg a message
      redir => contents
      call Console.error('foo bar')
      redir END
      Assert Equals(split(contents, '\r\?\n'), ['foo bar'])

      let messages = s:messages()
      Assert Equals(messages, ['foo bar'])
    End

    It sets v:errmsg
      redir => contents
      call Console.error('foo bar')
      redir END
      Assert Equals(v:errmsg, 'foo bar')
    End
  End

  Describe .ask({msg}[, {text}, {complete}])
    It returns '' while status is STATUS_BATCH
      Assert Equals(Console.ask('foo'), '')
    End
  End

  Describe .select({msg}, {candidates}[, {canceled}])
    It returns {canceled} while status is STATUS_BATCH
      Assert Equals(Console.select('foo', ['foo', 'bar']), '')
    End
  End

  Describe .confirm({msg}[, {text}])
    It returns 0 while status is STATUS_BATCH
      Assert Equals(Console.confirm('foo'), 0)
    End
  End

  Describe .capture({command})
    It return messages of {command}
      Assert Equals(Console.capture('echo "Hello"'), ['', 'Hello'])
    End
  End
End
