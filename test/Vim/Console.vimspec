Describe Vim.Console
  Before all
    function! TestVitalVimConsoleTrue() abort
      return 1
    endfunction

    function! TestVitalVimConsoleFalse() abort
      return 0
    endfunction

    function! s:messages() abort
      redir => contents
      messages
      redir END
      let l:messages = filter(split(contents, '\r\?\n'), '!empty(v:val)')
      " Remove a title console if exists
      if get(l:messages, 0, '') =~# '^Messages maintainer:'
        return l:messages[1:]
      else
        return l:messages
      endif
    endfunction
  End

  After all
    delfunction TestVitalVimConsoleTrue
    delfunction TestVitalVimConsoleFalse
  End

  Before
    let Console = vital#vital#import('Vim.Console')
    let Console.prefix = ''
    call Console.clear()
    set verbose=0
  End

  Describe .echo({msg}[, {hl}])
    It echo a {msg}
      redir => contents
      call Console.echo("foo\nbar")
      call Console.echo("foo\nbar")
      redir END
      Assert Equals(split(contents, '\r\?\n'), ['foo', 'bar', 'foo', 'bar'])
      let messages = s:messages()
      Assert Equals(messages, [])
    End

    It echo a {msg} with {prefix}
      let Console.prefix = '[prefix] '
      redir => contents
      call Console.echo("foo\nbar")
      call Console.echo("foo\nbar")
      redir END
      Assert Equals(split(contents, '\r\?\n'), [
            \ '[prefix] foo',
            \ '[prefix] bar',
            \ '[prefix] foo',
            \ '[prefix] bar',
            \])
      let messages = s:messages()
      Assert Equals(messages, [])
    End
  End

  Describe .echon({msg}[, {hl}])
    It echon a {msg}
      redir => contents
      redraw
      call Console.echon("foo\nbar")
      call Console.echon("foo\nbar")
      echo ""
      redir END
      Assert Equals(split(contents, '\r\?\n'), ['foo', 'barfoo', 'bar'])
      let messages = s:messages()
      Assert Equals(messages, [])
    End

    It echon a {msg} without {prefix}
      let Console.prefix = '[prefix] '
      redir => contents
      redraw
      call Console.echon("foo\nbar")
      call Console.echon("foo\nbar")
      echo ""
      redir END
      Assert Equals(split(contents, '\r\?\n'), ['foo', 'barfoo', 'bar'])
      let messages = s:messages()
      Assert Equals(messages, [])
    End
  End

  Describe .echomsg({hl} [, {msg}...])
    It echomsg a {msg}
      redir => contents
      call Console.echomsg("foo\nbar")
      call Console.echomsg("foo\nbar")
      redir END
      Assert Equals(split(contents, '\r\?\n'), ['foo', 'bar', 'foo', 'bar'])
      let messages = s:messages()
      Assert Equals(messages, ['foo', 'bar', 'foo', 'bar'])
    End

    It echomsg a {msg} with {prefix}
      let Console.prefix = '[prefix] '
      redir => contents
      call Console.echomsg("foo\nbar")
      call Console.echomsg("foo\nbar")
      redir END
      Assert Equals(split(contents, '\r\?\n'), [
            \ '[prefix] foo',
            \ '[prefix] bar',
            \ '[prefix] foo',
            \ '[prefix] bar',
            \])
      let messages = s:messages()
      Assert Equals(messages, [
            \ '[prefix] foo',
            \ '[prefix] bar',
            \ '[prefix] foo',
            \ '[prefix] bar',
            \])
    End
  End

  Describe .input({hl}, {msg}[, {text}, {complete}])
    It returns a given string
      call timer_start(0, { -> feedkeys('Hello World' . "\<CR>", 't') })
      Assert Equals(Console.input('None', 'foo'), 'Hello World')
    End

    It returns an empty string if user hit <CR> immediately
      call timer_start(0, { -> feedkeys("\<CR>", 't') })
      Assert Equals(Console.input('None', 'foo'), '')
    End

    It returns 0 if user hit <Esc>
      call timer_start(0, { -> feedkeys('Hello World' . "\<Esc>", 't') })
      Assert Equals(Console.input('None', 'foo'), 0)
    End
  End

  Describe .inputlist({hl}, {textlist})
    It returns a selected index
      call timer_start(0, { -> feedkeys('1' . "\<CR>", 't') })
      Assert Equals(Console.inputlist('None', ['foo', 'bar']), 1)
      call timer_start(0, { -> feedkeys('2' . "\<CR>", 't') })
      Assert Equals(Console.inputlist('None', ['foo', 'bar']), 2)
    End

    It returns a given number
      call timer_start(0, { -> feedkeys('100' . "\<CR>", 't') })
      Assert Equals(Console.inputlist('None', ['foo', 'bar']), 100)
    End

    It returns 0 if nothing has given
      call timer_start(0, { -> feedkeys("\<CR>", 't') })
      Assert Equals(Console.inputlist('None', ['foo', 'bar']), 0)
    End

    It returns 0 if non number has given
      call timer_start(0, { -> feedkeys('Hello World' . "\<CR>", 't') })
      Assert Equals(Console.inputlist('None', ['foo', 'bar']), 0)
    End
  End

  Describe .clear()
    It fills up messages with empty strings
      echomsg 'foo'
      echomsg 'foo'
      echomsg 'foo'
      echomsg 'foo'
      call Console.clear()
      let messages = s:messages()
      Assert Equals(len(messages), 0)
    End
  End

  Describe .debug({msg})
    It echomsg messages when &verbose > 0
      redir => contents
      verbose call Console.debug('foo bar')
      redir END
      Assert Equals(split(contents, '\r\?\n'), ['foo bar'])

      let messages = s:messages()
      Assert Equals(messages, ['foo bar'])
    End

    It does nothing otherwise
      redir => contents
      call Console.debug('foo bar')
      redir END
      Assert Equals(split(contents, '\r\?\n'), [])

      let messages = s:messages()
      Assert Equals(messages, [])
    End
  End

  Describe .info({msg})
    It echomsg a message
      redir => contents
      call Console.info('foo bar')
      redir END
      Assert Equals(split(contents, '\r\?\n'), ['foo bar'])

      let messages = s:messages()
      Assert Equals(messages, ['foo bar'])
    End

    It sets v:statusmsg
      redir => contents
      call Console.info('foo bar')
      redir END
      Assert Equals(v:statusmsg, 'foo bar')
    End
  End

  Describe .warn({msg})
    It echomsg a message
      redir => contents
      call Console.warn('foo bar')
      redir END
      Assert Equals(split(contents, '\r\?\n'), ['foo bar'])

      let messages = s:messages()
      Assert Equals(messages, ['foo bar'])
    End

    It sets v:warningmsg
      redir => contents
      call Console.warn('foo bar')
      redir END
      Assert Equals(v:warningmsg, 'foo bar')
    End
  End

  Describe .error({msg})
    It echomsg a message
      redir => contents
      call Console.error('foo bar')
      redir END
      Assert Equals(split(contents, '\r\?\n'), ['foo bar'])

      let messages = s:messages()
      Assert Equals(messages, ['foo bar'])
    End

    It sets v:errmsg
      redir => contents
      call Console.error('foo bar')
      redir END
      Assert Equals(v:errmsg, 'foo bar')
    End
  End

  Describe .ask({msg}[, {text}, {complete}])
    It returns a given string
      call timer_start(0, { -> feedkeys('Hello World' . "\<CR>", 't') })
      Assert Equals(Console.ask('foo'), 'Hello World')
    End

    It returns an empty string if user hit <CR> immediately
      call timer_start(0, { -> feedkeys("\<CR>", 't') })
      Assert Equals(Console.ask('foo'), '')
    End

    It returns 0 if user hit <Esc>
      call timer_start(0, { -> feedkeys('Hello World' . "\<Esc>", 't') })
      Assert Equals(Console.ask('foo'), 0)
    End
  End

  Describe .select({msg}, {candidates}[, {canceled}])
    It returns a selected candidate string
      call timer_start(0, { -> feedkeys('1' . "\<CR>", 't') })
      Assert Equals(Console.select('hello', ['foo', 'bar']), 'foo')
      call timer_start(0, { -> feedkeys('2' . "\<CR>", 't') })
      Assert Equals(Console.select('hello', ['foo', 'bar']), 'bar')
    End

    " It returns a given number
    "   call timer_start(0, { -> feedkeys('100' . "\<CR>", 't') })
    "   Assert Equals(Console.select('hello', ['foo', 'bar']), 100)
    " End

    It returns {cancel} if nothing has given
      call timer_start(0, { -> feedkeys("\<CR>", 't') })
      Assert Equals(Console.select('hello', ['foo', 'bar']), '')
      call timer_start(0, { -> feedkeys("\<CR>", 't') })
      Assert Equals(Console.select('hello', ['foo', 'bar'], 0), 0)
    End

    It returns {cancel} if non number has given
      call timer_start(0, { -> feedkeys('Hello World' . "\<CR>", 't') })
      Assert Equals(Console.select('hello', ['foo', 'bar']), '')
      call timer_start(0, { -> feedkeys('Hello World' . "\<CR>", 't') })
      Assert Equals(Console.select('hello', ['foo', 'bar'], 0), 0)
    End
  End

  Describe .confirm({msg}[, {text}])
    It returns 1 if user answer y/ye/yes
      call timer_start(0, { -> feedkeys('y' . "\<CR>", 't') })
      Assert Equals(Console.confirm('foo'), 1)
      call timer_start(0, { -> feedkeys('Y' . "\<CR>", 't') })
      Assert Equals(Console.confirm('foo'), 1)
      call timer_start(0, { -> feedkeys('ye' . "\<CR>", 't') })
      Assert Equals(Console.confirm('foo'), 1)
      call timer_start(0, { -> feedkeys('Ye' . "\<CR>", 't') })
      Assert Equals(Console.confirm('foo'), 1)
      call timer_start(0, { -> feedkeys('YE' . "\<CR>", 't') })
      Assert Equals(Console.confirm('foo'), 1)
      call timer_start(0, { -> feedkeys('yes' . "\<CR>", 't') })
      Assert Equals(Console.confirm('foo'), 1)
      call timer_start(0, { -> feedkeys('Yes' . "\<CR>", 't') })
      Assert Equals(Console.confirm('foo'), 1)
      call timer_start(0, { -> feedkeys('YES' . "\<CR>", 't') })
      Assert Equals(Console.confirm('foo'), 1)
    End

    It returns 0 if user answer n/no
      call timer_start(0, { -> feedkeys('n' . "\<CR>", 't') })
      Assert Equals(Console.confirm('foo'), 0)
      call timer_start(0, { -> feedkeys('N' . "\<CR>", 't') })
      Assert Equals(Console.confirm('foo'), 0)
      call timer_start(0, { -> feedkeys('no' . "\<CR>", 't') })
      Assert Equals(Console.confirm('foo'), 0)
      call timer_start(0, { -> feedkeys('No' . "\<CR>", 't') })
      Assert Equals(Console.confirm('foo'), 0)
      call timer_start(0, { -> feedkeys('NO' . "\<CR>", 't') })
      Assert Equals(Console.confirm('foo'), 0)
    End

    It returns 0 if user hit <Esc>
      call timer_start(0, { -> feedkeys('y' . "\<Esc>", 't') })
      Assert Equals(Console.confirm('foo'), 0)
    End

    It uses {default} to determine 1/0 if user hit <CR> immediately
      call timer_start(0, { -> feedkeys("\<CR>", 't') })
      Assert Equals(Console.confirm('foo', 'y'), 1)
      call timer_start(0, { -> feedkeys("\<CR>", 't') })
      Assert Equals(Console.confirm('foo', 'n'), 0)
    End

    It repeats asking until user answer y/n
      call timer_start(0, { -> feedkeys('a' . "\<CR>", 't') })
      call timer_start(0, { -> feedkeys('b' . "\<CR>", 't') })
      call timer_start(0, { -> feedkeys('y' . "\<CR>", 't') })
      Assert Equals(Console.confirm('foo'), 1)
      call timer_start(0, { -> feedkeys('a' . "\<CR>", 't') })
      call timer_start(0, { -> feedkeys('b' . "\<CR>", 't') })
      call timer_start(0, { -> feedkeys('n' . "\<CR>", 't') })
      Assert Equals(Console.confirm('foo'), 0)
    End
  End

  Describe .capture({command})
    It return messages of {command}
      Assert Equals(Console.capture('echo "Hello"'), ['', 'Hello'])
    End
  End
End
