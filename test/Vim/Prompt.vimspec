let s:V = vital#of('vital')

function! TestVitalVimPromptTrue() abort
  return 1
endfunction
function! TestVitalVimPromptFalse() abort
  return 0
endfunction
function! s:messages() abort
  redir => contents
  messages
  redir END
  let l:messages = filter(split(contents, '\r\?\n'), '!empty(v:val)')
  " Remove a title message if exists
  if get(l:messages, 0, '') =~# '^Messages maintainer:'
    return l:messages[1:]
  else
    return l:messages
  endif
endfunction

Describe Vim.Prompt
  Before
    let Prompt = s:V.import('Vim.Prompt')
    let DEFAULT_CONFIG = {
          \ 'debug': 0,
          \ 'batch': 1,
          \}
    call Prompt.set_config(DEFAULT_CONFIG)
    call Prompt.clear()
  End
  After all
    delfunction TestVitalVimPromptTrue
    delfunction TestVitalVimPromptFalse
  End

  Describe .get_config()
    It returns a copy of a config dictionary
      let config = Prompt.get_config()
      Assert IsDict(config)
      Assert KeyExists(config, 'debug')
      Assert KeyExists(config, 'batch')
      Assert Equal(config, DEFAULT_CONFIG)

      let config2 = Prompt.get_config()
      Assert Equal(config, config2)
      Assert NotSame(config, config2)
    End
  End

  Describe .set_config({config})
    It overwrites existing config with {config}
      call Prompt.set_config({
            \ 'debug': 1,
            \ 'batch': 0,
            \})
      let config = Prompt.get_config()
      Assert Equal(config, {
            \ 'debug': 1,
            \ 'batch': 0,
            \})
    End
    It ignores unknown attributes
      call Prompt.set_config({
            \ 'debug': 1,
            \ 'batch': 0,
            \ 'unknown_attribute': 'bar',
            \})
      let config = Prompt.get_config()
      Assert Equal(config, {
            \ 'debug': 1,
            \ 'batch': 0,
            \})
    End
    It ignores missing attributes
      call Prompt.set_config({
            \ 'debug': 1,
            \})
      let config = Prompt.get_config()
      Assert Equal(config, extend(copy(DEFAULT_CONFIG), {
            \ 'debug': 1,
            \}))
    End
  End

  Describe .is_batch()
    It returns 0 if {config}.batch is 0
      call Prompt.set_config({'batch': 0})
      Assert False(Prompt.is_batch())
    End
    It returns 1 if {config}.batch is 1
      call Prompt.set_config({'batch': 1})
      Assert True(Prompt.is_batch())
    End
    It executes {config}.batch and return if it is funcref
      call Prompt.set_config({'batch': function('TestVitalVimPromptTrue')})
      Assert True(Prompt.is_batch())

      call Prompt.set_config({'batch': function('TestVitalVimPromptFalse')})
      Assert False(Prompt.is_batch())
    End
  End
  Describe .is_debug()
    It returns 0 if {config}.debug is 0
      call Prompt.set_config({'debug': 0})
      Assert False(Prompt.is_debug())
    End
    It returns 1 if {config}.debug is 1
      call Prompt.set_config({'debug': 1})
      Assert True(Prompt.is_debug())
    End
    It executes {config}.debug and return if it is funcref
      call Prompt.set_config({'debug': function('TestVitalVimPromptTrue')})
      Assert True(Prompt.is_debug())

      call Prompt.set_config({'debug': function('TestVitalVimPromptFalse')})
      Assert False(Prompt.is_debug())
    End
  End

  Describe .echo({hl}, {msg})
    It echo a {msg}
      redir => contents
      call Prompt.echo('None', "foo\nbar")
      redir END
      Assert Equals(split(contents, '\r\?\n'), ['foo', 'bar'])
      let messages = s:messages()
      Assert Equals(messages, [])
    End
  End
  Describe .echomsg({hl}, {msg})
    It echomsg a {msg}
      redir => contents
      call Prompt.echomsg('None', "foo\nbar")
      redir END
      Assert Equals(split(contents, '\r\?\n'), ['foo', 'bar'])
      let messages = s:messages()
      Assert Equals(messages, ['foo', 'bar'])
    End
  End
  Describe .input({hl}, {msg}[, {text}, {complete}])
    It returns '' while batch is 1
      Assert Equals(Prompt.input('None', 'foo'), '')
    End
  End
  Describe .inputlist({hl}, {msg}[, {text}, {complete}])
    It returns 0 while batch is 1
      Assert Equals(Prompt.inputlist('None', ['foo', 'bar']), 0)
    End
  End
  Describe .clear()
    It fills up messages with empty strings
      echomsg "foo"
      echomsg "foo"
      echomsg "foo"
      echomsg "foo"
      call Prompt.clear()
      let messages = s:messages()
      Assert Equals(len(messages), 0)
    End
  End

  Describe .debug([{msg}, ...])
    It echomsg messages with newlines if debug is 1
      call Prompt.set_config({'debug': 1})

      redir => contents
      call Prompt.debug('foo', 'bar', 0)
      redir END
      Assert Equals(split(contents, '\r\?\n'), ['foo', 'bar', '0'])

      let messages = s:messages()
      Assert Equals(messages, ['foo', 'bar', '0'])
    End
    It does nothing if debug is 0
      call Prompt.set_config({'debug': 0})

      redir => contents
      call Prompt.debug('foo', 'bar', 0)
      redir END
      Assert Equals(split(contents, '\r\?\n'), [])

      let messages = s:messages()
      Assert Equals(messages, [])
    End
  End
  Describe .info([{msg}, ...])
    It echomsg messages with newlines
      redir => contents
      call Prompt.info('foo', 'bar', 0)
      redir END
      Assert Equals(split(contents, '\r\?\n'), ['foo', 'bar', '0'])

      let messages = s:messages()
      Assert Equals(messages, ['foo', 'bar', '0'])
    End
  End
  Describe .warn([{msg}, ...])
    It echomsg messages with newlines
      redir => contents
      call Prompt.warn('foo', 'bar', 0)
      redir END
      Assert Equals(split(contents, '\r\?\n'), ['foo', 'bar', '0'])

      let messages = s:messages()
      Assert Equals(messages, ['foo', 'bar', '0'])
    End
  End
  Describe .error([{msg}, ...])
    It echomsg messages with newlines
      redir => contents
      call Prompt.error('foo', 'bar', 0)
      redir END
      Assert Equals(split(contents, '\r\?\n'), ['foo', 'bar', '0'])

      let messages = s:messages()
      Assert Equals(messages, ['foo', 'bar', '0'])
    End
  End

  Describe .ask({msg}[, {text}, {complete}])
    It returns '' when batch is 1
      Assert Equals(Prompt.ask('foo'), '')
    End
  End
  Describe .select({msg}, {candidates}[, {canceled}])
    It returns {canceled} when batch is 1
      Assert Equals(Prompt.select('foo', ['foo', 'bar']), '')
    End
  End
  Describe .confirm({msg}[, {text}])
    It returns 0 when batch is 1
      Assert Equals(Prompt.confirm('foo'), 0)
    End
  End
End

